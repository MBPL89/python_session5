{"title":"7. Data structures - lists, tuples, dictionaries","markdown":{"yaml":{"title":"7. Data structures - lists, tuples, dictionaries","jupyter":"python3"},"headingText":"Lists","containsRefs":false,"markdown":"\n\n\n\n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type. \n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n```{pyodide}\ntype([10, 20, 30, 40])\n```\n\n```{pyodide}\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n\nYou can create an empty list (and the fill it later):\n\n```{pyodide}\n[]\n```\n\nYou can also place a list inside a list (a *nested* list):\n\n```{pyodide}\n['spam', 2.0, 5, [10, 20]]\n```\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list. \n\n```{pyodide}\nnumbers = [17, 123]\nprint(numbers)\n```\n\n```{pyodide}\nnumbers[1] = 5\nprint(numbers)\n```\n\n### List operations\n\nThe + operator concatenates lists:\n\n```{pyodide}\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n\nThe * operator repeats a list a given number of times:\n\n```{pyodide}\n[0] * 4\n[0, 0, 0, 0]\n```\n\n```{pyodide}\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\nThe `in` operator also works on lists:\n\n```{pyodide}\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n\n```{pyodide}\nt[:4]\n```\n\n```{pyodide}\nt[3:]\n```\n\n### List methods\n\n- **append** adds an elemen to a list\n\n```{pyodide}\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n\n- **extend** takes a list as an argument and appends all of its elements\n\n```{pyodide}\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n\n- **sort** arranges the elements from low to high\n\n```{pyodide}\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n\nThe list.sort() method uses ascending order by default, but you can reverse that using the reverse=True arguement. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example). \n\n```{pyodide}\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n- **pop** modifies the list and returns the element that was removed\n\n```{pyodide}\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n\n- **del** removes the element, but does not return the removed element\n\n```{pyodide}\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n```{pyodide}\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n\nTo remove more than one element, you can use **del** with a slice index:\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n\n## Careful!! Lists do assignments by **reference**\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n```{pyodide}\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n\nThis is not what happens with lists. When you assing a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n```{pyodide}\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n\nIf you want to explicitely create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has. \n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.  \n\nTo create an empty dictionary you can: \n\n- use a **dict()** function\n\n```{pyodide}\nemptyD = dict()\nprint(emptyD)\n```\n\n- use curly brackets **{}**\n\n```{pyodide}\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n\nTo add items to the dictionary, you can use square brackets:\n\n```{pyodide}\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n\nYou can also create a dictionary with values already in it. \n\n```{pyodide}\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n```{pyodide}\n print(eng2sp['two'])\n```\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n```{pyodide}\n print(eng2sp['four'])\n```\n\nYou can check if a key is in the dictionary by using **in** operator\n\n```{pyodide}\n'one' in eng2sp\n```\n\n```{pyodide}\n'four' in eng2sp\n```\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n```{pyodide}\neng2sp.values()\n```\n\nYou can also convert it to a list\n\n```{pyodide}\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n```{pyodide}\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).  \nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n```{pyodide}\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n\nYou can use **get** method to be more efficient. \n\n**get**  takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value. \n\n```{pyodide}\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n\n```{pyodide}\nprint(nat.get('Stefano', ))\n```\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently. \n\n```{pyodide}\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. \n\nThe important difference is that tuples are *immutable*.  \n\nA tuple is a comma-separated list of values:\n\n```{pyodide}\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n```{pyodide}\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n\n```{pyodide}\nprint(t1)\nprint(t2)\n```\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n```{pyodide}\nt1[0] = 'A'\n```\n\nThe way around this is to replace one tuple with another:\n\n```{pyodide}\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.  \n\nCompare the two cells below:\n\n```{pyodide}\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n\n```{pyodide}\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n```{pyodide}\na, b = b, a\n\nprint(a)\n```\n\nWhen doing this, however, you have to be careful about the number of values and variables. \n\n```{pyodide}\na, b = 1, 2, 3\n```\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n```{pyodide}\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n\nYou can also change the order to value-key if you write a simple loop.\n\n```{pyodide}\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n\n## List, dictionary or tuple? \n\n- Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.  \n    - Tuples are faster and safer than lists (because they cannot be modified). \n    - For example, person’s credentials for your website, a set with names of the months.  \n    \n    \n- Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.  \n\n\n- Use lists when you want to store similar elements and when the order of elements in the sequence matters. \n\n","srcMarkdownNoYaml":"\n\n\n\n## Lists \n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type. \n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n```{pyodide}\ntype([10, 20, 30, 40])\n```\n\n```{pyodide}\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n\nYou can create an empty list (and the fill it later):\n\n```{pyodide}\n[]\n```\n\nYou can also place a list inside a list (a *nested* list):\n\n```{pyodide}\n['spam', 2.0, 5, [10, 20]]\n```\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list. \n\n```{pyodide}\nnumbers = [17, 123]\nprint(numbers)\n```\n\n```{pyodide}\nnumbers[1] = 5\nprint(numbers)\n```\n\n### List operations\n\nThe + operator concatenates lists:\n\n```{pyodide}\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n\nThe * operator repeats a list a given number of times:\n\n```{pyodide}\n[0] * 4\n[0, 0, 0, 0]\n```\n\n```{pyodide}\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\nThe `in` operator also works on lists:\n\n```{pyodide}\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n\n```{pyodide}\nt[:4]\n```\n\n```{pyodide}\nt[3:]\n```\n\n### List methods\n\n- **append** adds an elemen to a list\n\n```{pyodide}\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n\n- **extend** takes a list as an argument and appends all of its elements\n\n```{pyodide}\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n\n- **sort** arranges the elements from low to high\n\n```{pyodide}\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n\nThe list.sort() method uses ascending order by default, but you can reverse that using the reverse=True arguement. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example). \n\n```{pyodide}\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n- **pop** modifies the list and returns the element that was removed\n\n```{pyodide}\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n\n- **del** removes the element, but does not return the removed element\n\n```{pyodide}\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n```{pyodide}\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n\nTo remove more than one element, you can use **del** with a slice index:\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n\n## Careful!! Lists do assignments by **reference**\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n```{pyodide}\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n\nThis is not what happens with lists. When you assing a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n```{pyodide}\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n\nIf you want to explicitely create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has. \n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.  \n\nTo create an empty dictionary you can: \n\n- use a **dict()** function\n\n```{pyodide}\nemptyD = dict()\nprint(emptyD)\n```\n\n- use curly brackets **{}**\n\n```{pyodide}\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n\nTo add items to the dictionary, you can use square brackets:\n\n```{pyodide}\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n\nYou can also create a dictionary with values already in it. \n\n```{pyodide}\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n```{pyodide}\n print(eng2sp['two'])\n```\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n```{pyodide}\n print(eng2sp['four'])\n```\n\nYou can check if a key is in the dictionary by using **in** operator\n\n```{pyodide}\n'one' in eng2sp\n```\n\n```{pyodide}\n'four' in eng2sp\n```\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n```{pyodide}\neng2sp.values()\n```\n\nYou can also convert it to a list\n\n```{pyodide}\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n```{pyodide}\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).  \nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n```{pyodide}\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n\nYou can use **get** method to be more efficient. \n\n**get**  takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value. \n\n```{pyodide}\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n\n```{pyodide}\nprint(nat.get('Stefano', ))\n```\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently. \n\n```{pyodide}\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. \n\nThe important difference is that tuples are *immutable*.  \n\nA tuple is a comma-separated list of values:\n\n```{pyodide}\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n```{pyodide}\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n\n```{pyodide}\nprint(t1)\nprint(t2)\n```\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n```{pyodide}\nt1[0] = 'A'\n```\n\nThe way around this is to replace one tuple with another:\n\n```{pyodide}\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.  \n\nCompare the two cells below:\n\n```{pyodide}\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n\n```{pyodide}\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n```{pyodide}\na, b = b, a\n\nprint(a)\n```\n\nWhen doing this, however, you have to be careful about the number of values and variables. \n\n```{pyodide}\na, b = 1, 2, 3\n```\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n```{pyodide}\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n\nYou can also change the order to value-key if you write a simple loop.\n\n```{pyodide}\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n\n## List, dictionary or tuple? \n\n- Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.  \n    - Tuples are faster and safer than lists (because they cannot be modified). \n    - For example, person’s credentials for your website, a set with names of the months.  \n    \n    \n- Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.  \n\n\n- Use lists when you want to store similar elements and when the order of elements in the sequence matters. \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"c6-data-structures.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","draft-mode":"gone","drafts":["p5-strings-solved.qmd","challenge2-strings_solved.qmd"],"smooth-scroll":true,"theme":{"light":"materia","dark":"darkly"},"fontsize":"1.4em","linestretch":1.5,"title":"7. Data structures - lists, tuples, dictionaries","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}