{"title":"5. Data Structures","markdown":{"yaml":{"title":"5. Data Structures","author":"Dr. Piccoli","format":"live-html","pyodide":{"packages":["seaborn"]},"editor_options":{"chunk_output_type":"console"}},"headingText":"5. Data structures","containsRefs":false,"markdown":"\n\n```{=html}\n<style>\n/* Target the first tab (Demo) */\n.nav-pills .nav-item:nth-child(1) .nav-link {\n  background-color: #FFC20A; /* Yellow */\n  color: white;\n}\n\n/* Target the second tab (Example) */\n.nav-pills .nav-item:nth-child(2) .nav-link {\n  background-color: #5D3A9B; /* Purple */\n  color: white;\n}\n\n/* Target the third tab (Exercise) */\n.nav-pills .nav-item:nth-child(3) .nav-link {\n  background-color: #0C7BDC; /* Blue */\n  color: white;\n}\n\n/* Target the fourth tab (Activity) */\n.nav-pills .nav-item:nth-child(4) .nav-link {\n  background-color: #E66100; /* Orange */\n  color: white;\n}\n\n/* Target the fifth tab (Activity2) */\n.nav-pills .nav-item:nth-child(5) .nav-link {\n  background-color: #40B0A6; /* teal */\n  color: white;\n}\n\n/* Active tab styling */\n.nav-pills .nav-link.active {\n  background-color: #2E7D32; /* Customize active tab color */\n  color: white;\n}\n</style>\n```\n\n{{< include ./_extensions/r-wasm/live/_knitr.qmd >}} {{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}\n\n```{pyodide}\n#| autorun: true\n#| startover: false\n#| edit: false\n#| runbutton: false\n#| echo: false\nimport sys\nfrom io import StringIO\n\n```\n\n\n## Lists\n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type.\n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ntype([10, 20, 30, 40])\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n\nYou can create an empty list (and the fill it later):\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[]\n```\n\nYou can also place a list inside a list (a *nested* list):\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['spam', 2.0, 5, [10, 20]]\n```\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers = [17, 123]\nprint(numbers)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers[1] = 5\nprint(numbers)\n```\n\n### List operations\n\nThe `+` operator concatenates lists:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n\nThe `*` operator repeats a list a given number of times:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[0] * 4\n[0, 0, 0, 0]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\nThe `in` operator also works on lists:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[:4]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[3:]\n```\n\n### List methods\n\n:::{.callout-note}\n**append** adds an element to a list\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n\n:::{.callout-note}\n**extend** takes a list as an argument and appends all of its elements\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n\n:::{.callout-note}\n**sort** arranges the elements from low to high\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n\nThe `list.sort()` method uses ascending order by default, but you can reverse that using the `reverse=True` argument. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example).\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n:::{.callout-note}\n**pop** modifies the list and returns the element that was removed\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n\n:::{.callout-note}\n**del** removes the element, but does not return the removed element\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n\nTo remove more than one element, you can use **del** with a slice index:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n\n:::{.callout-warning}\nCareful!! Lists do assignments by **reference**\n:::\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n\nThis is not what happens with lists. When you assign a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n\nIf you want to explicitly create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.\n\nTo create an empty dictionary you can:\n\n:::{.callout-note}\nuse a **dict()** function\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD = dict()\nprint(emptyD)\n```\n\n:::{.callout-note}\nuse curly brackets **{}**\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n\nTo add items to the dictionary, you can use square brackets:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n\nYou can also create a dictionary with values already in it.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['two'])\n```\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['four'])\n```\n\nYou can check if a key is in the dictionary by using **in** operator\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'one' in eng2sp\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'four' in eng2sp\n```\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp.values()\n```\n\nYou can also convert it to a list\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).\n\nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n\nYou can use **get** method to be more efficient.\n\n**get** takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(nat.get('Stefano', ))\n```\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers.\n\n:::{.callout-note}\nThe important difference is that tuples are *immutable*.\n:::\n\nA tuple is a comma-separated list of values:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(t1)\nprint(t2)\n```\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1[0] = 'A'\n```\n\nThe way around this is to replace one tuple with another:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.\n\nCompare the two cells below:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = b, a\n\nprint(a)\n```\n\n:::{.callout-warning}\nWhen doing this, however, you have to be careful about the number of values and variables.\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = 1, 2, 3\n```\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n\nYou can also change the order to value-key if you write a simple loop.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n\n## List, dictionary or tuple?\n\n* Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.\n  + Tuples are faster and safer than lists (because they cannot be modified).\n  + For example, person’s credentials for your website, a set with names of the months.\n* Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.\n* Use lists when you want to store similar elements and when the order of elements in the sequence matters.\n\n\n::: disclaimer\n<p><strong>Images and GIFs Disclaimer:</strong> Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.</p>\n:::\n\n```{=html}\n<style>\n.disclaimer {\n  font-size: 0.8em;\n  color: #666;\n  border-top: 1px solid #ddd;\n  padding-top: 10px;\n  margin-top: 20px;\n}\n</style>\n```\n\n```{=html}\n<div>\n  {{< include footer.html >}}\n</div>\n```","srcMarkdownNoYaml":"\n\n```{=html}\n<style>\n/* Target the first tab (Demo) */\n.nav-pills .nav-item:nth-child(1) .nav-link {\n  background-color: #FFC20A; /* Yellow */\n  color: white;\n}\n\n/* Target the second tab (Example) */\n.nav-pills .nav-item:nth-child(2) .nav-link {\n  background-color: #5D3A9B; /* Purple */\n  color: white;\n}\n\n/* Target the third tab (Exercise) */\n.nav-pills .nav-item:nth-child(3) .nav-link {\n  background-color: #0C7BDC; /* Blue */\n  color: white;\n}\n\n/* Target the fourth tab (Activity) */\n.nav-pills .nav-item:nth-child(4) .nav-link {\n  background-color: #E66100; /* Orange */\n  color: white;\n}\n\n/* Target the fifth tab (Activity2) */\n.nav-pills .nav-item:nth-child(5) .nav-link {\n  background-color: #40B0A6; /* teal */\n  color: white;\n}\n\n/* Active tab styling */\n.nav-pills .nav-link.active {\n  background-color: #2E7D32; /* Customize active tab color */\n  color: white;\n}\n</style>\n```\n\n{{< include ./_extensions/r-wasm/live/_knitr.qmd >}} {{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}\n\n```{pyodide}\n#| autorun: true\n#| startover: false\n#| edit: false\n#| runbutton: false\n#| echo: false\nimport sys\nfrom io import StringIO\n\n```\n\n# 5. Data structures\n\n## Lists\n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type.\n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ntype([10, 20, 30, 40])\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n\nYou can create an empty list (and the fill it later):\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[]\n```\n\nYou can also place a list inside a list (a *nested* list):\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['spam', 2.0, 5, [10, 20]]\n```\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers = [17, 123]\nprint(numbers)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers[1] = 5\nprint(numbers)\n```\n\n### List operations\n\nThe `+` operator concatenates lists:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n\nThe `*` operator repeats a list a given number of times:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[0] * 4\n[0, 0, 0, 0]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\nThe `in` operator also works on lists:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[:4]\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[3:]\n```\n\n### List methods\n\n:::{.callout-note}\n**append** adds an element to a list\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n\n:::{.callout-note}\n**extend** takes a list as an argument and appends all of its elements\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n\n:::{.callout-note}\n**sort** arranges the elements from low to high\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n\nThe `list.sort()` method uses ascending order by default, but you can reverse that using the `reverse=True` argument. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example).\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n:::{.callout-note}\n**pop** modifies the list and returns the element that was removed\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n\n:::{.callout-note}\n**del** removes the element, but does not return the removed element\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n\nTo remove more than one element, you can use **del** with a slice index:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n\n:::{.callout-warning}\nCareful!! Lists do assignments by **reference**\n:::\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n\nThis is not what happens with lists. When you assign a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n\nIf you want to explicitly create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.\n\nTo create an empty dictionary you can:\n\n:::{.callout-note}\nuse a **dict()** function\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD = dict()\nprint(emptyD)\n```\n\n:::{.callout-note}\nuse curly brackets **{}**\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n\nTo add items to the dictionary, you can use square brackets:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n\nYou can also create a dictionary with values already in it.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['two'])\n```\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['four'])\n```\n\nYou can check if a key is in the dictionary by using **in** operator\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'one' in eng2sp\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'four' in eng2sp\n```\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp.values()\n```\n\nYou can also convert it to a list\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).\n\nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n\nYou can use **get** method to be more efficient.\n\n**get** takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(nat.get('Stefano', ))\n```\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers.\n\n:::{.callout-note}\nThe important difference is that tuples are *immutable*.\n:::\n\nA tuple is a comma-separated list of values:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(t1)\nprint(t2)\n```\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1[0] = 'A'\n```\n\nThe way around this is to replace one tuple with another:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.\n\nCompare the two cells below:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = b, a\n\nprint(a)\n```\n\n:::{.callout-warning}\nWhen doing this, however, you have to be careful about the number of values and variables.\n:::\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = 1, 2, 3\n```\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n\nYou can also change the order to value-key if you write a simple loop.\n\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n\n## List, dictionary or tuple?\n\n* Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.\n  + Tuples are faster and safer than lists (because they cannot be modified).\n  + For example, person’s credentials for your website, a set with names of the months.\n* Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.\n* Use lists when you want to store similar elements and when the order of elements in the sequence matters.\n\n\n::: disclaimer\n<p><strong>Images and GIFs Disclaimer:</strong> Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.</p>\n:::\n\n```{=html}\n<style>\n.disclaimer {\n  font-size: 0.8em;\n  color: #666;\n  border-top: 1px solid #ddd;\n  padding-top: 10px;\n  margin-top: 20px;\n}\n</style>\n```\n\n```{=html}\n<div>\n  {{< include footer.html >}}\n</div>\n```"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["C:\\Users\\admin\\OneDrive\\Working\\Teaching\\Coding\\python_session5\\_extensions\\r-wasm\\live\\live.lua"],"output-file":"completed.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","ojs-engine":true,"revealjs-plugins":[],"editor":"visual","title":"5. Data Structures","author":"Dr. Piccoli","pyodide":{"packages":["seaborn"]},"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}