{
  "hash": "71481bfb16fdfb6a39290bb4bd0472e8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '7. Data structures - lists, tuples, dictionaries'\njupyter: python3\n---\n\n\n\n\n\n\n\n\n## Lists \n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type. \n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n\n\n\n\n\n```{pyodide}\ntype([10, 20, 30, 40])\n```\n\n```{pyodide}\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n\n\n\n\n\n\nYou can create an empty list (and the fill it later):\n\n\n\n\n\n\n```{pyodide}\n[]\n```\n\n\n\n\n\n\nYou can also place a list inside a list (a *nested* list):\n\n\n\n\n\n\n```{pyodide}\n['spam', 2.0, 5, [10, 20]]\n```\n\n\n\n\n\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list. \n\n\n\n\n\n\n```{pyodide}\nnumbers = [17, 123]\nprint(numbers)\n```\n\n```{pyodide}\nnumbers[1] = 5\nprint(numbers)\n```\n\n\n\n\n\n\n### List operations\n\nThe + operator concatenates lists:\n\n\n\n\n\n\n```{pyodide}\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n\n\n\n\n\n\nThe * operator repeats a list a given number of times:\n\n\n\n\n\n\n```{pyodide}\n[0] * 4\n[0, 0, 0, 0]\n```\n\n```{pyodide}\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\n\n\n\n\n\nThe `in` operator also works on lists:\n\n\n\n\n\n\n```{pyodide}\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n\n\n\n\n\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n\n```{pyodide}\nt[:4]\n```\n\n```{pyodide}\nt[3:]\n```\n\n\n\n\n\n\n### List methods\n\n- **append** adds an elemen to a list\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n\n\n\n\n\n\n- **extend** takes a list as an argument and appends all of its elements\n\n\n\n\n\n\n```{pyodide}\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n\n\n\n\n\n\n- **sort** arranges the elements from low to high\n\n\n\n\n\n\n```{pyodide}\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n\n\n\n\n\n\nThe list.sort() method uses ascending order by default, but you can reverse that using the reverse=True arguement. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example). \n\n\n\n\n\n\n```{pyodide}\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n\n```{pyodide}\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n\n\n\n\n\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n- **pop** modifies the list and returns the element that was removed\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n\n\n\n\n\n\n- **del** removes the element, but does not return the removed element\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n\n\n\n\n\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n\n\n\n\n\n\nTo remove more than one element, you can use **del** with a slice index:\n\n\n\n\n\n\n```{pyodide}\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n\n\n\n\n\n\n## Careful!! Lists do assignments by **reference**\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n\n\n\n\n\n```{pyodide}\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n\n\n\n\n\n\nThis is not what happens with lists. When you assing a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n\n\n\n\n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n```{pyodide}\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n\n\n\n\n\n\nIf you want to explicitely create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has. \n\n\n\n\n\n\n```{pyodide}\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n\n\n\n\n\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.  \n\nTo create an empty dictionary you can: \n\n- use a **dict()** function\n\n\n\n\n\n\n```{pyodide}\nemptyD = dict()\nprint(emptyD)\n```\n\n\n\n\n\n\n- use curly brackets **{}**\n\n\n\n\n\n\n```{pyodide}\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n\n\n\n\n\n\nTo add items to the dictionary, you can use square brackets:\n\n\n\n\n\n\n```{pyodide}\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n\n\n\n\n\n\nYou can also create a dictionary with values already in it. \n\n\n\n\n\n\n```{pyodide}\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n\n\n\n\n\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n\n\n\n\n\n```{pyodide}\n print(eng2sp['two'])\n```\n\n\n\n\n\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n\n\n\n\n\n```{pyodide}\n print(eng2sp['four'])\n```\n\n\n\n\n\n\nYou can check if a key is in the dictionary by using **in** operator\n\n\n\n\n\n\n```{pyodide}\n'one' in eng2sp\n```\n\n```{pyodide}\n'four' in eng2sp\n```\n\n\n\n\n\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n\n\n\n\n\n```{pyodide}\neng2sp.values()\n```\n\n\n\n\n\n\nYou can also convert it to a list\n\n\n\n\n\n\n```{pyodide}\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n\n\n\n\n\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n\n\n\n\n\n```{pyodide}\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n\n\n\n\n\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).  \nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n\n\n\n\n\n```{pyodide}\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n\n\n\n\n\n\nYou can use **get** method to be more efficient. \n\n**get**  takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value. \n\n\n\n\n\n\n```{pyodide}\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n\n```{pyodide}\nprint(nat.get('Stefano', ))\n```\n\n\n\n\n\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently. \n\n\n\n\n\n\n```{pyodide}\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n\n\n\n\n\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. \n\nThe important difference is that tuples are *immutable*.  \n\nA tuple is a comma-separated list of values:\n\n\n\n\n\n\n```{pyodide}\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n\n\n\n\n\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n\n\n\n\n\n```{pyodide}\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n\n```{pyodide}\nprint(t1)\nprint(t2)\n```\n\n\n\n\n\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n\n\n\n\n\n```{pyodide}\nt1[0] = 'A'\n```\n\n\n\n\n\n\nThe way around this is to replace one tuple with another:\n\n\n\n\n\n\n```{pyodide}\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n\n\n\n\n\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.  \n\nCompare the two cells below:\n\n\n\n\n\n\n```{pyodide}\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n\n```{pyodide}\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n\n\n\n\n\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n\n\n\n\n\n```{pyodide}\na, b = b, a\n\nprint(a)\n```\n\n\n\n\n\n\nWhen doing this, however, you have to be careful about the number of values and variables. \n\n\n\n\n\n\n```{pyodide}\na, b = 1, 2, 3\n```\n\n\n\n\n\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n\n\n\n\n\n```{pyodide}\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n\n\n\n\n\n\nYou can also change the order to value-key if you write a simple loop.\n\n\n\n\n\n\n```{pyodide}\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n\n\n\n\n\n\n## List, dictionary or tuple? \n\n- Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.  \n    - Tuples are faster and safer than lists (because they cannot be modified). \n    - For example, person’s credentials for your website, a set with names of the months.  \n    \n    \n- Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.  \n\n\n- Use lists when you want to store similar elements and when the order of elements in the sequence matters. \n\n",
    "supporting": [
      "c6-data-structures_files"
    ],
    "filters": [],
    "includes": {}
  }
}