{
  "hash": "11f9fbf3627617f7fcf880c43d17aed6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"5. Data Structures\"\nauthor: \"Dr. Piccoli\"\nformat: live-html\npyodide:\n  packages:\n    - seaborn\neditor_options: \n  chunk_output_type: console\n---\n\n```{=html}\n<style>\n/* Target the first tab (Demo) */\n.nav-pills .nav-item:nth-child(1) .nav-link {\n  background-color: #FFC20A; /* Yellow */\n  color: white;\n}\n\n/* Target the second tab (Example) */\n.nav-pills .nav-item:nth-child(2) .nav-link {\n  background-color: #5D3A9B; /* Purple */\n  color: white;\n}\n\n/* Target the third tab (Exercise) */\n.nav-pills .nav-item:nth-child(3) .nav-link {\n  background-color: #0C7BDC; /* Blue */\n  color: white;\n}\n\n/* Target the fourth tab (Activity) */\n.nav-pills .nav-item:nth-child(4) .nav-link {\n  background-color: #E66100; /* Orange */\n  color: white;\n}\n\n/* Target the fifth tab (Activity2) */\n.nav-pills .nav-item:nth-child(5) .nav-link {\n  background-color: #40B0A6; /* teal */\n  color: white;\n}\n\n/* Active tab styling */\n.nav-pills .nav-link.active {\n  background-color: #2E7D32; /* Customize active tab color */\n  color: white;\n}\n</style>\n```\n\n::: {.cell}\n\n:::\n\n::: {.cell autorun='true' startover='false' edit='false' runbutton='false'}\n```{pyodide}\n#| autorun: true\n#| startover: false\n#| edit: false\n#| runbutton: false\n#| echo: false\nimport sys\nfrom io import StringIO\n\n```\n:::\n\n\n\n# 5. Data structures\n\n## Lists\n\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list, they can be any type.\n\nThe simplest way to create a list is to enclose the elements in square brackets:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ntype([10, 20, 30, 40])\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['crunchy frog', 'ram bladder', 'lark vomit']\n```\n:::\n\n\n\nYou can create an empty list (and the fill it later):\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[]\n```\n:::\n\n\n\nYou can also place a list inside a list (a *nested* list):\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n['spam', 2.0, 5, [10, 20]]\n```\n:::\n\n\n\n### Lists are mutable\n\nUnlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers = [17, 123]\nprint(numbers)\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnumbers[1] = 5\nprint(numbers)\n```\n:::\n\n\n\n### List operations\n\nThe `+` operator concatenates lists:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n```\n:::\n\n\n\nThe `*` operator repeats a list a given number of times:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[0] * 4\n[0, 0, 0, 0]\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n:::\n\n\n\nThe `in` operator also works on lists:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\n```\n:::\n\n\n\n### List slices\n\nSlicing lists works the same way as slicing strings.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[:4]\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt[3:]\n```\n:::\n\n\n\n### List methods\n\n:::{.callout-note}\n**append** adds an element to a list\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n```\n:::\n\n\n\n:::{.callout-note}\n**extend** takes a list as an argument and appends all of its elements\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n```\n:::\n\n\n\n:::{.callout-note}\n**sort** arranges the elements from low to high\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n```\n:::\n\n\n\nThe `list.sort()` method uses ascending order by default, but you can reverse that using the `reverse=True` argument. More importantly it uses Unicode sorting, but it has a second argument called key that allows you to specify a specific sorting criterion (see second example).\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['joseph', 'Glenn', 'Sally' ]\nfriends.sort()\nprint(friends)\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'Glenn', 'Sally' ]\nfriends.sort(reverse = True)\nprint(friends)\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfriends = ['Joseph', 'glenn', 'Sally' ]\nfriends.sort(key = lambda x: x.lower())\nprint(friends)\n```\n:::\n\n\n\n### Deleting elements from a list\n\nIf you know the index of an element, you can use *pop* or *del*\n\n:::{.callout-note}\n**pop** modifies the list and returns the element that was removed\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\nprint(x)\n```\n:::\n\n\n\n:::{.callout-note}\n**del** removes the element, but does not return the removed element\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n```\n:::\n\n\n\nIf you know the element you want to remove (but not the index), you can use **remove**:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'b']\nt.remove('b')\nprint(t)\n```\n:::\n\n\n\nTo remove more than one element, you can use **del** with a slice index:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n```\n:::\n\n\n\n:::{.callout-warning}\nCareful!! Lists do assignments by **reference**\n:::\n\nIf you assign a string to another string, you are creating **two separate** variables. That means that you will have two **separate memory references** where the value of the two variables are stored.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nstring1 = \"The cat is on the table\"\nprint(f'the value of string1 is: {string1}')\nstring2 = string1\nstring2 = 'Pippo'\nprint(f'the value of string2 is: {string2}')\nprint(f'the value of string1 is: {string1}')\n```\n:::\n\n\n\nThis is not what happens with lists. When you assign a list to another list, you are assigning **the reference** to the first list, there is **one memory location** storing the value and **both lists** point to that same location.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\ndef reference_function(list_passed) :\n    list_passed.append('weird')\n\nlist1 = [1, 2, 3]\nreference_function(list1)\nprint(list1)\n```\n:::\n\n\n\nIf you want to explicitly create a copy of a list, thereby creating a new memory location to store separate values from the original list you cannot do a simple assignment. You must instead use the **copy() method** that every list has.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nlist1 = [0, 1, 2, 3]\nprint(f'the value of list1 is: {list1}')\nlist2 = list1.copy()\nlist2.append('Pippo')\nprint(f'the value of list2 is: {list2}')\nprint(f'the value of list1 is: {list1}')\n```\n:::\n\n\n\n## Dictionaries\n\nA dictionary is like a list, but more general. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. The association of a key and a value is called a **key-value** pair or sometimes an item.\n\nTo create an empty dictionary you can:\n\n:::{.callout-note}\nuse a **dict()** function\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD = dict()\nprint(emptyD)\n```\n:::\n\n\n\n:::{.callout-note}\nuse curly brackets **{}**\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2 = {}\nprint(emptyD2)\ntype(emptyD2)\n```\n:::\n\n\n\nTo add items to the dictionary, you can use square brackets:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nemptyD2['key1'] = 1\nemptyD2['key2'] = \"two\"\n\nprint(emptyD2)\n```\n:::\n\n\n\nYou can also create a dictionary with values already in it.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nprint(eng2sp)\n```\n:::\n\n\n\nKeep in mind that the order of the key-value pairs might not be the same. The order of items in a dictionary is unpredictable because dictionaries are unordered sets.\n\nHowever it is not a problem because we use the keys to look up the corresponding values:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['two'])\n```\n:::\n\n\n\nKeep in mind that the key must be unique. Otherwise you will not be able to identify the values.\n\nIf the key isn't in the dictionary, you get an exception:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n print(eng2sp['four'])\n```\n:::\n\n\n\nYou can check if a key is in the dictionary by using **in** operator\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'one' in eng2sp\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n'four' in eng2sp\n```\n:::\n\n\n\nTo see whether something appears as a value in a dictionary, you can use the method **values**, which returns the values\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\neng2sp.values()\n```\n:::\n\n\n\nYou can also convert it to a list\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nvals = list(eng2sp.values())\n\nprint(vals)\n```\n:::\n\n\n\nAnalogically, you can use **keys** method, to find all the keys in the dictionary\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nks = list(eng2sp.keys())\n\nprint(ks)\n```\n:::\n\n\n\n### Dictionaries as a set of counters\n\nImagine that you want to count the letters in a string (read: elements in a sequence).\n\nYou could create a dictionary to hold the output for you where keys are the letters and values are counts.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nfruit = 'banana'\nd = dict()\nfor c in fruit:\n    if c not in d:\n        d[c] = 1\n    else:\n        d[c] = d[c] + 1\nprint(d)\n```\n:::\n\n\n\nYou can use **get** method to be more efficient.\n\n**get** takes a key and a default value. If the key exists in the dictionary, it reurns its value. If it does not, it returns the default value.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nnat = { 'Gabriele' : 'IT' , 'Marcin' : 'PL', 'Federico': 'IT'}\nprint(nat.get('Marcin', 0))\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(nat.get('Stefano', ))\n```\n:::\n\n\n\nIn the example above, 0 is the default value that is printed only when the key does not exist in the dictionary (think of it as a small *if / else* statement where 0 appears in the *else* block). You can replace it with other value types. For example, you could print *NA* instead of a *0*.\n\nYou can use this method to count the elements of a sequence more efficiently.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = dict()\nfor c in fruit:\n    d[c] = d.get(c,0) + 1\nprint(d)\n```\n:::\n\n\n\n## Tuples\n\nA **tuple** is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers.\n\n:::{.callout-note}\nThe important difference is that tuples are *immutable*.\n:::\n\nA tuple is a comma-separated list of values:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = 'a', 'b', 'c', 'd', 'e'\n```\n:::\n\n\n\nIt is common to enclose tuples in parentheses (so you can find them quickly), but it is not necessary.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt2 = ('a', 'b', 'c', 'd', 'e')\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nprint(t1)\nprint(t2)\n```\n:::\n\n\n\nMost list operators work on tuples. However, if you try to modify an element of a tuple, you will get an error.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1[0] = 'A'\n```\n:::\n\n\n\nThe way around this is to replace one tuple with another:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nt1 = ('A',) + t1[1:]\n\nprint(t1)\n```\n:::\n\n\n\n### Tuple assignment\n\nOne of the unique features of the Python language is the ability to have a tuple on the left side of an assignment statement so you can assign more than one variable at a time.\n\nCompare the two cells below:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na = 1\nb = 2\n\nprint(a)\nprint(b)\n```\n:::\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nc, d = 3, 4\nprint(c)\nprint(d)\n```\n:::\n\n\n\nA clever application of tuple assignment allows us to swap the values of two variables in a single statement:\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = b, a\n\nprint(a)\n```\n:::\n\n\n\n:::{.callout-warning}\nWhen doing this, however, you have to be careful about the number of values and variables.\n:::\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\na, b = 1, 2, 3\n```\n:::\n\n\n\n### Tuples and dictionaries\n\nBefore you saw how to find **keys** or **values** of a dictioanry. Dictionaries have also a method called **items** which returns a list of tuples, each tuple being showing a key value pair.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nd = {'a':10, 'b':1, 'c':22}\nt = list(d.items())\nprint(t)\n```\n:::\n\n\n\nYou can also change the order to value-key if you write a simple loop.\n\n\n\n::: {.cell startover='false' autorun='false' min-lines='3'}\n```{pyodide}\n#| startover: false\n#| autorun: false\n#| min-lines: 3\nl = list()\nfor key, val in d.items() :\n    l.append( (val, key) )\n\nprint(l)\n```\n:::\n\n\n\n## List, dictionary or tuple?\n\n* Use a tuple when you know what information goes in it, it is a constant set of values (unlikely to change) and all you’re going to do with it is iterate through it.\n  + Tuples are faster and safer than lists (because they cannot be modified).\n  + For example, person’s credentials for your website, a set with names of the months.\n* Use a dictionary when you have an unordered set of unique keys that map to values, like in an address book.\n* Use lists when you want to store similar elements and when the order of elements in the sequence matters.\n\n\n::: disclaimer\n<p><strong>Images and GIFs Disclaimer:</strong> Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.</p>\n:::\n\n\n\n```{=html}\n<style>\n.disclaimer {\n  font-size: 0.8em;\n  color: #666;\n  border-top: 1px solid #ddd;\n  padding-top: 10px;\n  margin-top: 20px;\n}\n</style>\n```\n\n```{=html}\n<div>\n<!-- Footer Section -->\n<div style=\"\n  width: 100vw;\n  height: auto;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  background-color: #f9f9f9;\n  font-size: 12px;\n  border-top: 1px solid #ddd;\n  box-sizing: border-box;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  padding: 10px 20px;\n\">\n  <!-- Left-aligned -->\n  <div style=\"text-align: left; font-size: 16px;\">\n    © 2025. All Rights Reserved.\n  </div>\n  \n\n  <!-- Right-aligned -->\n  <div style=\"text-align: right; font-size: 16px;\">\n    Enabled by <a href=\"https://biagio-palese.netlify.app\" target=\"_blank\" style=\"text-decoration: none; color: #0073e6;\">Dr. Biagio Palese</a>\n  </div>\n</div>\n\n<!-- Mobile Responsiveness -->\n<style>\n  @media screen and (max-width: 768px) {\n    div[style*=\"width: 100vw\"] {\n      flex-direction: column;\n      height: auto;\n      padding: 10px 15px;\n    }\n    \n    div[style*=\"width: 100vw\"] > div {\n      text-align: center;\n      margin-bottom: 5px;\n    }\n  }\n</style>\n\n</div>\n```",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}